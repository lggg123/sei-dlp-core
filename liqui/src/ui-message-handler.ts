/**
 * UI Message Handler for SEI DLP Dashboard Integration
 * Handles messages from the Next.js UI and processes them through Eliza
 */

import { type Character, type Evaluator, type Memory, type Provider, type Action, type Handler, type IAgentRuntime, type State } from '@elizaos/core';
import { apiClient } from './plugin-overrides.js';

export interface UIMessage {
  content: {
    text: string;
    source: string;
  };
  user: string;
  room: string;
  context: {
    chainId: number;
    vaultAddress?: string;
    currentPage?: string;
    timestamp: string;
    vaultData?: any;
    userPreferences?: any;
  };
}

export interface UIResponse {
  response: string;
  confidence: number;
  actions: string[];
  suggestions: string[];
  responseTime: string;
  metadata?: any;
}

interface ExtendedMemoryContent {
  text: string;
  source?: string;
  metadata?: {
    chainId?: number;
    vaultAddress?: string;
    currentPage?: string;
    timestamp?: string;
    vaultData?: any;
    userPreferences?: any;
  };
  [key: string]: any; // Index signature for compatibility
}

/**
 * Message handler that processes UI messages through Eliza's AI system
 */
export class UIMessageHandler {
  private runtime: IAgentRuntime;

  constructor(runtime: IAgentRuntime) {
    this.runtime = runtime;
  }

  /**
   * Process message from UI dashboard
   */
  async handleUIMessage(message: UIMessage): Promise<UIResponse> {
    const startTime = Date.now();
    
    try {
      // Create memory object for the message
      const memory: Memory = {
        id: crypto.randomUUID() as `${string}-${string}-${string}-${string}-${string}`,
        entityId: crypto.randomUUID() as `${string}-${string}-${string}-${string}-${string}`,
        agentId: this.runtime.agentId,
        roomId: crypto.randomUUID() as `${string}-${string}-${string}-${string}-${string}`,
        content: {
          text: message.content.text,
          source: message.content.source || 'sei-dlp-dashboard',
          metadata: {
            chainId: message.context.chainId,
            vaultAddress: message.context.vaultAddress,
            currentPage: message.context.currentPage,
            timestamp: message.context.timestamp,
            vaultData: message.context.vaultData,
            userPreferences: message.context.userPreferences
          }
        } as ExtendedMemoryContent,
        createdAt: Date.now(),
        embedding: [] // Will be generated by runtime
      };

      // Create initial state
      const state: State = await this.runtime.composeState(memory);

      // Process the message through Eliza's evaluation and action pipeline
      const response = await this.processMessageThroughEliza(memory, state);

      const responseTime = `${Date.now() - startTime}ms`;

      return {
        response: response.text,
        confidence: response.confidence || 0.85,
        actions: response.actions || [],
        suggestions: response.suggestions || this.generateContextualSuggestions(message),
        responseTime,
        metadata: {
          processingSource: 'eliza-agent',
          chainId: message.context.chainId,
          vaultAddress: message.context.vaultAddress,
          aiEngineIntegration: response.aiEngineUsed || false
        }
      };
    } catch (error) {
      console.error('Error processing UI message:', error);
      
      // Fallback response
      return {
        response: this.generateFallbackResponse(message),
        confidence: 0.6,
        actions: [],
        suggestions: this.generateContextualSuggestions(message),
        responseTime: `${Date.now() - startTime}ms`,
        metadata: {
          processingSource: 'eliza-fallback',
          error: error instanceof Error ? error.message : 'Unknown error',
          chainId: message.context.chainId
        }
      };
    }
  }

  /**
   * Process message through Eliza's AI pipeline
   */
  private async processMessageThroughEliza(memory: Memory, state: State): Promise<{
    text: string;
    confidence?: number;
    actions?: string[];
    suggestions?: string[];
    aiEngineUsed?: boolean;
  }> {
    // Check if message is vault-related and needs AI analysis
    const messageText = (memory.content as ExtendedMemoryContent).text?.toLowerCase() || '';
    const vaultAddress = (memory.content as ExtendedMemoryContent).metadata?.vaultAddress;
    
    let aiEngineResponse = null;
    let aiEngineUsed = false;

    // Route to Python AI engine for specific queries
    if (this.shouldRouteToAIEngine(messageText, vaultAddress)) {
      try {
        aiEngineResponse = await this.callAIEngine(messageText, memory.content.metadata);
        aiEngineUsed = true;
      } catch (error) {
        console.warn('AI Engine unavailable, using Eliza-only processing:', error);
      }
    }

    // Generate response using Eliza's character and knowledge
    let responseText = '';
    let confidence = 0.85;

    if (aiEngineResponse) {
      // Incorporate AI engine results into Eliza's response
      responseText = this.formatAIEngineResponse(aiEngineResponse, messageText);
      confidence = Math.min(0.95, confidence + 0.1); // Higher confidence with AI engine
    } else {
      // Use Eliza's character-based response generation
      responseText = await this.generateCharacterResponse(memory, state);
    }

    return {
      text: responseText,
      confidence,
      actions: this.extractActions(messageText, aiEngineResponse),
      suggestions: this.generateContextualSuggestions(memory),
      aiEngineUsed
    };
  }

  /**
   * Determine if message should be routed to AI engine
   */
  private shouldRouteToAIEngine(messageText: string, vaultAddress?: string): boolean {
    const aiKeywords = [
      'predict', 'prediction', 'forecast',
      'rebalance', 'rebalancing', 'optimize',
      'range', 'optimal', 'best',
      'analysis', 'analyze', 'recommend',
      'apy', 'yield', 'returns',
      'risk', 'volatility', 'impermanent loss'
    ];

    return aiKeywords.some(keyword => messageText.includes(keyword)) || !!vaultAddress;
  }

  /**
   * Call Python AI engine for analysis
   */
  private async callAIEngine(messageText: string, metadata: any): Promise<any> {
    if (messageText.includes('predict') || messageText.includes('range') || messageText.includes('optimal')) {
      // Route to prediction endpoint
      return await apiClient.callPythonAI('/predict/optimal-range', {
        vault_address: metadata.vaultAddress || '0x0000000000000000000000000000000000000000',
        current_price: 1.0, // Would get from market data
        volume_24h: 1000000,
        volatility: 0.25,
        liquidity: 5000000,
        timeframe: '1d',
        chain_id: metadata.chainId || 713715
      });
    } else if (messageText.includes('rebalance')) {
      // Route to rebalance analysis
      return await apiClient.callPythonAI('/analyze/rebalance', {
        vault_address: metadata.vaultAddress || '0x0000000000000000000000000000000000000000',
        current_tick: 0,
        lower_tick: -1000,
        upper_tick: 1000,
        utilization_rate: 0.5,
        market_conditions: {
          tvl: 1000000,
          impermanent_loss: -0.5,
          last_rebalance: new Date().toISOString()
        }
      });
    }

    return null;
  }

  /**
   * Format AI engine response into natural language
   */
  private formatAIEngineResponse(aiResponse: any, originalMessage: string): string {
    if (aiResponse.lower_price && aiResponse.upper_price) {
      // Prediction response
      return `ðŸŽ¯ Based on SEI AI Engine analysis: Optimal range is $${aiResponse.lower_price.toFixed(4)} - $${aiResponse.upper_price.toFixed(4)} with ${(aiResponse.confidence * 100).toFixed(1)}% confidence. Expected APR: ${(aiResponse.expected_apr * 100).toFixed(2)}%. ${aiResponse.reasoning || 'This range optimizes fee capture while minimizing impermanent loss risk.'}`;
    } else if (aiResponse.action && aiResponse.urgency) {
      // Rebalance response
      return `âš¡ AI Rebalance Analysis: ${aiResponse.action.replace('_', ' ')} (${aiResponse.urgency} priority). Expected improvement: ${(aiResponse.expected_improvement || 0).toFixed(2)}%. Gas cost: ~$${(aiResponse.gas_cost_estimate || 0.15).toFixed(3)} on SEI. ${aiResponse.risk_assessment || 'Rebalancing recommended for optimal capital efficiency.'}`;
    }

    return `ðŸ¤– AI Engine analysis complete. ${aiResponse.reasoning || 'Check the dashboard for detailed metrics and recommendations.'}`;
  }

  /**
   * Generate character-based response using Eliza's personality
   */
  private async generateCharacterResponse(memory: Memory, state: State): Promise<string> {
    const messageText = (memory.content as ExtendedMemoryContent).text?.toLowerCase() || '';
    const vaultAddress = (memory.content as ExtendedMemoryContent).metadata?.vaultAddress;
    
    // Use character patterns for SEI DLP responses
    if (messageText.includes('sei') || messageText.includes('chain')) {
      return `âš¡ SEI's 400ms finality is perfect for active liquidity management! Unlike Ethereum's $50+ rebalancing costs, SEI enables frequent optimization at ~$0.15 per transaction. This lets us capture more fees and reduce impermanent loss.`;
    }
    
    if (messageText.includes('vault') || vaultAddress) {
      return `ðŸŽ¯ I'm analyzing your vault performance on Chain 713715. SEI's parallel execution and fast finality make it ideal for concentrated liquidity strategies. Would you like me to check current utilization and suggest rebalancing?`;
    }
    
    if (messageText.includes('apy') || messageText.includes('yield')) {
      return `ðŸ’° Current vault yields are looking strong! Our AI models target 15-25% APY through optimal range management and cross-protocol arbitrage. SEI's speed advantage lets us capture opportunities other chains miss.`;
    }
    
    if (messageText.includes('risk') || messageText.includes('safe')) {
      return `ðŸ›¡ï¸ Risk management is key in DeFi. I monitor impermanent loss, volatility clustering, and liquidity depth. SEI's fast finality allows rapid position adjustments when market conditions change.`;
    }
    
    return `ðŸ¤– I'm Liqui, your SEI DLP specialist! I can help with vault optimization, rebalancing strategies, yield predictions, and risk assessment. What specific aspect of your liquidity position would you like to explore?`;
  }

  /**
   * Extract actionable items from the message
   */
  private extractActions(messageText: string, aiResponse: any): string[] {
    const actions: string[] = [];
    
    if (messageText.includes('rebalance')) {
      actions.push('ANALYZE_REBALANCE', 'CHECK_GAS_COSTS');
    }
    
    if (messageText.includes('deposit') || messageText.includes('withdraw')) {
      actions.push('REVIEW_POSITION', 'CALCULATE_IMPACT');
    }
    
    if (messageText.includes('predict') || messageText.includes('forecast')) {
      actions.push('RUN_PREDICTION_MODEL', 'ANALYZE_MARKET_DATA');
    }
    
    if (aiResponse?.action === 'rebalance_required') {
      actions.push('EXECUTE_REBALANCE', 'MONITOR_POSITION');
    }
    
    return actions;
  }

  /**
   * Generate contextual suggestions based on message and context
   */
  private generateContextualSuggestions(message: UIMessage | Memory): string[] {
    const suggestions: string[] = [];
    let text = '';
    let context: any = {};
    
    if ('content' in message && 'context' in message) {
      // UIMessage
      text = (message as UIMessage).content.text;
      context = (message as UIMessage).context;
    } else {
      // Memory
      text = (message as Memory).content.text || '';
      context = ((message as Memory).content as ExtendedMemoryContent).metadata || {};
    }
    
    // Context-aware suggestions
    if (context?.vaultAddress) {
      suggestions.push(
        `Analyze vault ${context.vaultAddress.slice(0, 8)}... performance`,
        `Check rebalancing opportunities for this vault`,
        `Review risk metrics and IL exposure`
      );
    } else {
      suggestions.push(
        'Show me the best performing vaults',
        'What are current SEI DLP yields?',
        'Explain SEI advantages for liquidity provision'
      );
    }
    
    if (text.toLowerCase().includes('gas') || text.toLowerCase().includes('cost')) {
      suggestions.push(
        'Compare gas costs: SEI vs Ethereum',
        'Calculate rebalancing profitability'
      );
    }
    
    // Always include general help
    suggestions.push(
      'Help me optimize my yield strategy',
      'Show me AI predictions for next 24h'
    );
    
    return suggestions.slice(0, 4); // Limit to 4 suggestions
  }

  /**
   * Generate fallback response for errors
   */
  private generateFallbackResponse(message: UIMessage): string {
    const messageText = message.content.text.toLowerCase();
    
    if (messageText.includes('rebalance')) {
      return `âš¡ For rebalancing assistance, I recommend checking your vault's utilization rate. If it's below 60%, rebalancing could improve fee capture. SEI's 400ms finality makes this cost-effective at ~$0.15 per transaction.`;
    }
    
    if (messageText.includes('vault') && message.context.vaultAddress) {
      return `ðŸŽ¯ I'm analyzing vault ${message.context.vaultAddress.slice(0, 8)}... on SEI Chain 713715. Check the dashboard for current metrics or ask me specific questions about optimization strategies.`;
    }
    
    return `ðŸ¤– I'm Liqui, your SEI DLP AI assistant. I specialize in vault optimization, yield strategies, and rebalancing recommendations. The main dashboard has detailed analytics, or you can ask me specific questions about your positions.`;
  }
}

/**
 * Express route handler for UI messages
 */
export function createUIMessageRoute(runtime: IAgentRuntime) {
  const handler = new UIMessageHandler(runtime);
  
  return async (req: any, res: any) => {
    try {
      const message: UIMessage = req.body;
      
      // Validate message structure
      if (!message.content?.text || !message.user || !message.context?.chainId) {
        return res.status(400).json({
          success: false,
          error: 'Invalid message format',
          required: ['content.text', 'user', 'context.chainId']
        });
      }
      
      // Process message
      const response = await handler.handleUIMessage(message);
      
      res.json({
        success: true,
        ...response
      });
    } catch (error) {
      console.error('UI message route error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to process message',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  };
}